// Generated by CoffeeScript 1.10.0
(function() {
  var _bubblePos, _cellAt, _cellPos, _createCell, _normalizeHeadPos, _setSymbol, calc, draw, procStep, progTuple, progTupleArr, programs, strToInput, strToProgram, tm, updateDraw;

  if (typeof tm === "undefined" || tm === null) {
    window.tm = tm = {};
  }

  programs = {};

  progTupleArr = function(ar) {
    return progTuple(ar[0], ar[1], ar[2], ar[3], ar[4]);
  };

  progTuple = function(q0, s0, q1, s1, d) {
    var r;
    r = {
      q0: q0,
      s0: (s0 === "_" ? null : s0[0]),
      q1: q1,
      s1: (s1 === "_" ? null : s1[0]),
      d: parseInt(d)
    };
    return r;
  };

  procStep = function(q1, s1, d, rule, expand) {
    return {
      q1: q1,
      s1: s1,
      d: d,
      rule: rule,
      expand: expand
    };
  };

  strToProgram = function(str, nameToSave) {
    var command, commands, j, len, result, s0, tuples;
    commands = str.split(",").map(function(s) {
      return s.trim().split(/\s+/);
    });
    tuples = [];
    result = {
      tuples: tuples
    };
    for (j = 0, len = commands.length; j < len; j++) {
      command = commands[j];
      if (command.length === 2 && command[0].toUpperCase() === "ACCEPT") {
        result.acceptState = command[1];
      }
      if (command.length === 2 && command[0].toUpperCase() === "REJECT") {
        result.rejectState = command[1];
      } else if (command.length === 2 && command[0].toUpperCase() === "INITIAL") {
        result.initState = command[1];
      } else if (command.length === 4 && command[2].toUpperCase() === "EXEC") {
        s0 = command[1];
        tuples.push({
          q0: command[0],
          s0: (s0 === "_" ? null : s0[0]),
          exec: command[3]
        });
      } else if (command.length === 5) {
        tuples.push(progTupleArr(command));
      }
    }
    if (typeof nameToSave === "string" && !nameToSave.match(/^\s*$/g)) {
      programs[nameToSave] = result;
    }
    return result;
  };

  strToInput = function(str) {
    return str.split('').map(function(s) {
      if (s === "_") {
        return null;
      } else {
        return s;
      }
    });
  };

  calc = function(program, input, maxSteps, pos) {
    var acceptState, error, execResult, expand, j, len, ref, rejectState, state, step, steps, sym, tuple;
    if (maxSteps == null) {
      maxSteps = 10000;
    }
    if (pos == null) {
      pos = 0;
    }
    state = program.initState;
    acceptState = program.acceptState;
    rejectState = program.rejectState;
    steps = [];
    while (state !== acceptState && state !== rejectState) {
      if (steps.length > maxSteps) {
        return {
          steps: steps,
          output: input,
          finalState: state,
          finalPos: pos,
          outOfSteps: true
        };
      }
      step = null;
      execResult = null;
      sym = input[pos];
      ref = program.tuples;
      for (j = 0, len = ref.length; j < len; j++) {
        tuple = ref[j];
        if (sym === tuple.s0 && state === tuple.q0) {
          if (tuple.exec != null) {
            if (programs[tuple.exec] != null) {
              execResult = calc(programs[tuple.exec], input, maxSteps - steps.length, pos);
              steps.push({
                rule: tuple,
                exec: tuple.exec
              });
              steps.push.apply(steps, execResult.steps);
              if ((execResult.error == null) && !execResult.outOfSteps) {
                steps.push({
                  rule: tuple,
                  execEnd: tuple.exec
                });
              }
              pos = execResult.finalPos;
              state = execResult.finalState;
            } else {
              console.log("not found " + tuple.exec);
            }
          } else {
            state = tuple.q1;
            input[pos] = tuple.s1;
            pos += tuple.d;
            expand = 0;
            if (pos === -1) {
              input.unshift(null);
              pos = 0;
              expand = -1;
            } else if (typeof input[pos] === "undefined") {
              input[pos] = null;
              expand = 1;
            }
            step = procStep(state, tuple.s1, tuple.d, tuple, expand);
          }
          break;
        }
      }
      if (step != null) {
        steps.push(step);
      } else if (execResult !== null) {
        if (execResult.error != null) {
          console.log(execResult.error);
          console.log(program);
          console.log(input);
          console.log(state + " " + pos);
          error = {
            message: execResult.error.message,
            state: state,
            input: sym
          };
          break;
        }
        if (execResult.outOfSteps) {
          return {
            steps: steps,
            output: input,
            finalState: state,
            finalPos: pos,
            outOfSteps: true
          };
        }
      } else {
        console.log(program);
        console.log(input);
        console.log(state + " " + pos);
        error = {
          message: "Illegal State/Input.",
          state: state,
          input: sym
        };
        break;
      }
    }
    return {
      steps: steps,
      output: input,
      finalState: state,
      finalPos: pos,
      error: error,
      accept: state === acceptState,
      reject: state === rejectState
    };
  };

  _normalizeHeadPos = function(headPos, target) {
    var cellWidth, firstCellMargin, firstCellWrap, tape;
    tape = target.children(".tape");
    firstCellWrap = tape.children(":first");
    cellWidth = firstCellWrap.width();
    firstCellMargin = parseInt(firstCellWrap.css("margin-left").replace("px", ""));
    if (headPos < 4 * cellWidth) {
      return {
        headPos: 4 * cellWidth,
        firstCellMargin: firstCellMargin + (4 * cellWidth - headPos)
      };
    } else if (headPos > tape.width() - 4 * cellWidth) {
      return {
        headPos: tape.width() - 4 * cellWidth,
        firstCellMargin: firstCellMargin - (headPos - (tape.width() - 4 * cellWidth))
      };
    } else {
      return {
        headPos: headPos,
        firstCellMargin: firstCellMargin
      };
    }
  };

  _cellPos = function(pos, target) {
    return jQuery(target.find(".tapeCellWrap")[pos]).position().left;
  };

  _cellAt = function(pos, target) {
    return jQuery(target.find(".tapeCell")[pos]);
  };

  _setSymbol = function(cell, sym) {
    if (sym === null) {
      return cell.html("&nbsp;");
    } else {
      return cell.text(sym);
    }
  };

  _createCell = function(symbol) {
    var cell, cellWrap;
    cell = jQuery(document.createElement("span"));
    cell.addClass("tapeCell");
    _setSymbol(cell, symbol);
    cellWrap = jQuery(document.createElement("span"));
    cellWrap.addClass("tapeCellWrap").append(cell);
    return cellWrap;
  };

  _bubblePos = function(headPos, head, bubble, target) {
    return headPos + head.width() - (bubble.width()) / 2;
  };

  draw = function(tape, pos, state, target) {
    var bubble, head, headPos, j, len, normalize, offset, sym, symPos, tapeView;
    target = jQuery(target);
    offset = target.data("offset");
    tapeView = target.children(".tape");
    tapeView.find(".tapeCell").html("&nbsp;");
    for (symPos = j = 0, len = tape.length; j < len; symPos = ++j) {
      sym = tape[symPos];
      if (offset + symPos + 3 > tapeView.children().length) {
        tapeView.append(_createCell(null));
        tapeView.append(_createCell(null));
        tapeView.append(_createCell(null));
      }
      _setSymbol(_cellAt(symPos + offset, target), sym);
    }
    head = target.children(".machineHead");
    head.text(state);
    headPos = _cellPos(pos + offset, target);
    normalize = _normalizeHeadPos(headPos, target);
    headPos = normalize.headPos;
    tapeView.children(":first").css("margin-left", normalize.firstCellMargin + "px");
    head.css("left", headPos);
    bubble = target.children(".bubble");
    bubble.css("bottom", 0);
    bubble.css("left", _bubblePos(headPos, head, bubble, target));
    bubble.text("hello,\nhuman!");
    return target.data("pos", pos);
  };

  updateDraw = function(step, target, nextAction) {
    var after, before, bubble, cellWidth, firstCellMargin, firstCellWrap, head, headPos, i, interval, j, li, normalize, offset, pos, r, ref, refer, tape, toAdd;
    target = jQuery(target);
    if (step.exec != null) {
      li = jQuery("<li></li>");
      li.text(step.exec);
      jQuery("#stack ul").prepend(li);
      if (nextAction) {
        return nextAction();
      }
    } else if (step.execEnd != null) {
      jQuery("#stack ul").children("li:first").remove();
      if (nextAction) {
        return nextAction();
      }
    } else {
      head = target.children(".machineHead");
      tape = target.children(".tape");
      bubble = target.children(".bubble");
      offset = target.data("offset");
      firstCellWrap = tape.children(":first");
      cellWidth = firstCellWrap.width();
      firstCellMargin = parseInt(firstCellWrap.css("margin-left").replace("px", ""));
      head.text(step.q1);
      r = step.rule;
      bubble.text(r.q0 + " " + (r.s0 === null ? "_" : r.s0) + "\n" + r.q1 + " " + (r.s1 === null ? "_" : r.s1) + " " + r.d);
      pos = target.data("pos");
      _setSymbol(_cellAt(pos + offset, target), step.s1);
      pos += step.d;
      if (step.expand === -1) {
        offset -= 1;
        pos = 0;
      }
      if (offset < 5) {
        refer = _cellAt(pos + offset, target).parent();
        before = refer.position().left;
        toAdd = 8 - offset;
        for (i = j = 1, ref = toAdd; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
          console.log(i + "/" + toAdd);
          firstCellWrap.after(_createCell(null));
        }
        after = refer.position().left;
        firstCellWrap.css("margin-left", (firstCellMargin - (after - before)) + "px");
        offset += toAdd;
      } else if (offset + pos + 4 > tape.children().length) {
        tape.append(_createCell(null));
        tape.append(_createCell(null));
        tape.append(_createCell(null));
        tape.append(_createCell(null));
      }
      target.data("pos", pos);
      target.data("offset", offset);
      interval = MAX_INTEVAL - jQuery('#speed').slider("value");
      headPos = _cellPos(pos + offset, target);
      normalize = _normalizeHeadPos(headPos, target);
      headPos = normalize.headPos;
      if (normalize.firstCellMargin !== firstCellMargin) {
        firstCellWrap.animate({
          "margin-left": normalize.firstCellMargin + "px"
        }, interval, "swing");
      }
      head.animate({
        "left": headPos + "px"
      }, interval, "swing", nextAction);
      return bubble.animate({
        "left": _bubblePos(headPos, head, bubble, target) + "px"
      }, interval, "swing");
    }
  };

  tm.programs = programs;

  tm.strToProgram = strToProgram;

  tm.strToInput = strToInput;

  tm.calc = calc;

  tm.draw = draw;

  tm.updateDraw = updateDraw;

}).call(this);

//# sourceMappingURL=turingmachine.js.map
